---
title: "AMF communities in DOK (SoilClim)"
author: "Katja Kozjek"
date: "`r Sys.Date()`"
output: 
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(warning = FALSE, message = FALSE)

```

# Prepare the environment

```{r setting the environment, message=F, warning=F, echo=F}

#clean everything
#rm(list=ls())

#load libraries
library(dada2); packageVersion("dada2") 
library(phyloseq); packageVersion("phyloseq") 
library(vegan); packageVersion("vegan") 
library(ggplot2); packageVersion("ggplot2")
library(dplyr); packageVersion("dplyr")
library(tidyverse); packageVersion("tidyverse")
library(ggpubr); packageVersion("ggpubr")
library(devtools); packageVersion("devtools")
library(ape); packageVersion("ape")
library(brms); packageVersion("brms") 
library(shinystan); packageVersion("shinystan") 
library(picante); packageVersion("picante")
library(indicspecies); packageVersion("indicspecies")
library(ggvegan); packageVersion("ggvegan")
library(devtools); packageVersion("devtools")

```

# Start with DADA2 pipeline, create ASVs from fastq files
## set path

```{r set path}

path_fastq <- "/Users/Katja/Box Sync/PhD Lund Katja/Sequencing/PacBio AMF/Sequencing data AMF/dada2/AMF_DOK trial/samples"
list.files(path_fastq) #listing all files in the path
fns <- sort(list.files(path_fastq, pattern=".fq", full.names = TRUE)) #selection of all fastq files
sample.names <- sapply(strsplit(basename(fns), "_"), `[`, 2)
print(sample.names)

```

## visualize sequence quality 

```{r sequence quality, echo=F}

plotQualityProfile(fns[1:6])
plotQualityProfile(fns[7:12])
plotQualityProfile(fns[13:18])
plotQualityProfile(fns[19:24])
plotQualityProfile(fns[25:30])
plotQualityProfile(fns[31:36])
plotQualityProfile(fns[37:42])
plotQualityProfile(fns[43:48])

```

## length distribution of the original sequences 

```{r original length distribution}

#inspect length distribution of sequences to determine how to filter the sequences
length_fns <- lapply(path_fastq, function(fn) nchar(getSequences(fn)))
length <- do.call(c, length_fns)
hist(length, 100) #looks good, majority between 1400 and 1700
mean(length); median(length) 

```

## filter and trim original sequences 

```{r filter + trim}

#place filtered files in filtered/ subdirectory 
filt_path <- file.path(path_fastq, "filtered") 
filt_fns <- file.path(path_fastq, "filtered", paste0(sample.names, "_filt.fq.gz"))
names(filt_fns) <- sample.names

#filter from 1400 to 1650
filt_out <- filterAndTrim(fns, filt_fns, minQ=2, minLen=1450, maxLen=1650, maxN=0, rm.phix=FALSE, maxEE=3, multithread = FALSE) #we retain only reads with fewer than three exp. errors 
print(filt_out)

#csv file containing number of input and output/filtered sequences
write.csv(filt_out, "/Users/Katja/Box Sync/PhD Lund Katja/Sequencing/PacBio AMF/Sequencing data AMF/dada2/AMF_DOK trial/PacBio_AMF_workflow/results_dada2/filtered_seq.csv") 

```

## inspect length distribution of filtered sequences

```{r length distribution filtered sequences}

length_fns_filt <- lapply(filt_path, function(fn) nchar(getSequences(fn)))
length_filt <- do.call(c, length_fns_filt)
hist(length_filt, 100)
mean(length_filt); median(length_filt)
#1529.076
#1529

```

## dereplication of identical reads
 + dereplication combines all identical sequencing reads into into “unique sequences” with a corresponding “abundance”: the number of reads with that unique sequence
+ collapsing together all reads that encode the same sequence

```{r dereplication}

#collapse identical sequences
derep <- derepFastq(filt_fns, verbose=TRUE)
names(derep) <- sample.names #name the derep-class objects by the sample names

```

## error rates
+ error rates for each possible transition

```{r error rates}

set.seed(100)
err <- learnErrors(derep, errorEstimationFunction = PacBioErrfun, BAND_SIZE = 32, verbose = TRUE)  
#103155500 total bases in 67095 reads from 12 samples will be used for learning the error rates.

plotErrors(err)
plotErrors(err, nominalQ=TRUE) #red line shows the error rates, the estimated error rates (black line) are a good fit to the observed rates (points), error rates should drop with the increased quality 

```

## denoise 
+ infer the sequence variants in each sample
+ separate true biological sequences from errors

```{r denoise}

dada_dd <- dada(derep, err = err, BAND_SIZE = 32, multithread=TRUE, verbose = TRUE, pool = "pseudo") #number of true sequences
dada_dd[[1]] #check only the first sample

```

# Construct sequence variant (ASV) table, a higher-resolution version of the OTU table produced by traditional methods

```{r ASV table}

seqtab <- makeSequenceTable(dada_dd); dim(seqtab) #48 972
table(nchar(getSequences(seqtab))) #distibution of sequence lengths 
#shortest 1468, longest 1634

saveRDS(seqtab, "all_seq.rds")

#extract original sequences, belonging to 972 ASVs

asv_seqs_original <- colnames(seqtab)
asv_headers_original <- vector(dim(seqtab)[2], mode = "character")
for (i in 1:dim(seqtab)[2]) {
  asv_headers_original[i] <- paste(">ASV", i, sep = "_")
}
asv_fasta_original <- c(rbind(asv_headers_original, asv_seqs_original))
write(asv_fasta_original, "ASVs_original.fasta")

```

## remove chimeras 

```{r remove chimeras}

seqtab.nochim <- removeBimeraDenovo(seqtab, method="consensus", multithread=TRUE, verbose=TRUE)
dim(seqtab.nochim) 
#48 962
#chimeras removed 
#seqtab.nochim file is the final file, samples and sequences that represents ASVs

#what proportion of the sequence variants are chimeras
sum(seqtab.nochim)/sum(seqtab) 
#0.9958734
1-sum(seqtab.nochim)/sum(seqtab)  #0.004126584

```

## summary, track retained sequences

```{r summarize}

getN <- function(x) sum(getUniques(x))
track <- cbind(filt_out, sapply(dada_dd, getN), rowSums(seqtab.nochim))
colnames(track) <- c("input", "filtered", "denoised", "nonchim")
rownames(track) <- sample.names
print(track)
class(track) #it is a matrix

#save summary 
write.csv(track, "/Users/Katja/Box Sync/PhD Lund Katja/Sequencing/PacBio AMF/Sequencing data AMF/dada2/AMF_DOK trial/PacBio_AMF_workflow/results_dada2/summary_seq.csv")

#plot the distribution of sequence length 
plot(sort(unname(rowSums(seqtab.nochim))))

#species richness
rarecurve(seqtab.nochim)

```

# Export fasta file 

```{r fasta files}

#give our sequence headers more manageable names (ASV_1, ASV_2...) and write out a FASTA of our ASV seqs
asv_seqs <- colnames(seqtab.nochim)
asv_headers <- vector(dim(seqtab.nochim)[2], mode = "character")
for (i in 1:dim(seqtab.nochim)[2]) {
  asv_headers[i] <- paste(">ASV", i, sep = "_")
}
asv_fasta <- c(rbind(asv_headers, asv_seqs))

#export fasta file with all 962 ASVs

write(asv_fasta, "/Users/Katja/Box Sync/PhD Lund Katja/Sequencing/PacBio AMF/Sequencing data AMF/dada2/AMF_DOK trial/PacBio_AMF_workflow/results_dada2/ASVs_processed.fasta")

```

# Export count table

```{r count table}

asv_tab <- (seqtab.nochim)
colnames(asv_tab) <- sub(">", "", asv_headers)

write.table(asv_tab, "/Users/Katja/Box Sync/PhD Lund Katja/Sequencing/PacBio AMF/Sequencing data AMF/dada2/AMF_DOK trial/PacBio_AMF_workflow/results_dada2/ASVs_counts.csv", sep = ",", quote = FALSE, col.names = NA)

#matrix: rows corresponding to samples, columns with ASV, the value of each entry is the number of times that ASV was observed in the sample

```

# Taxonomy with UNITE 2020

```{r taxonomy unite 2020}

set.seed(NULL) #return to the original state by unsetting the seed
set.seed(62)

#take UNITE database

taxonomy_unite <- assignTaxonomy(seqtab.nochim, "/Users/Katja/Box Sync/PhD Lund Katja/Sequencing/PacBio AMF/Sequencing data AMF/dada2/AMF_DOK trial/reference databases/sh_general_release_dynamic_04.02.2020_dev.fasta", multithread=TRUE, tryRC = TRUE)

tax_unite2020 <- taxonomy_unite # Removing sequence rownames for display only
rownames(tax_unite2020) <- NULL
rownames(tax_unite2020) <- getSequences(asv_tab)
head(tax_unite2020)

write.csv(tax_unite2020, "/Users/Katja/Box Sync/PhD Lund Katja/Sequencing/PacBio AMF/Sequencing data AMF/dada2/AMF_DOK trial/PacBio_AMF_workflow/results_dada2/tax_unite2020.csv")

write.csv(taxonomy_unite, "/Users/Katja/Box Sync/PhD Lund Katja/Sequencing/PacBio AMF/Sequencing data AMF/dada2/AMF_DOK trial/PacBio_AMF_workflow/results_dada2/tax_unite2020_seq.csv")

```

# Create phyloseq object with 962 ASV, based on UNITE taxonomy

```{r create phyloseq}

#OTU table
OTU = otu_table(asv_tab, taxa_are_rows = FALSE)
#962 taxa, 48 samples
OTUr = transform_sample_counts(OTU, function(x) x/sum(x))

#TAX table from UNITE

taxa_unite <- read.csv("/Users/Katja/Box Sync/PhD Lund Katja/Sequencing/PacBio AMF/Sequencing data AMF/dada2/AMF_DOK trial/PacBio_AMF_workflow/results_dada2/tax_unite2020.csv", sep = ",", row.names = 1)

tax_unite_table = tax_table(as.matrix(taxa_unite))
TAX = tax_table(tax_unite_table)

#META file 
meta_file = read.csv("/Users/Katja/Box Sync/PhD Lund Katja/Sequencing/PacBio AMF/Sequencing data AMF/dada2/Meta files AMF/meta_DOK.csv", sep=",", row.names=1) 
meta_file = sample_data(data.frame(meta_file))

#create phyloseq

physeq_unite = phyloseq(OTU, TAX, meta_file)
physeq_unite
#OTU_table; 962 taxa, 48 samples
#tax_table; 962 taxa, by 7 taxonomic ranks
#meta_file; 48 samples, 24 variables 

#phyloseq with relative abundance
physeq_unite_rel = phyloseq(OTUr, tax_unite, meta_file)

sort(sample_sums(physeq_unite), decreasing = F) 
sum(otu_table(physeq_unite)) #185825 sequencing reads in all samples

#add tree
library("ape"); packageVersion("ape") #5.3
unite_tree = rtree(ntaxa(physeq_unite), rooted=TRUE, tip.label=taxa_names(physeq_unite))
plot((unite_tree))

#add unite tree to phyloseq object 
physeq_unite = merge_phyloseq(physeq_unite, unite_tree)
physeq_unite

#plot relative abundance 
plot_bar(tax_glom(physeq_unite_rel, "Phylum"), fill="Phylum")
plot_bar(physeq_unite_rel, x = "treatment:farming_system", fill = "Class")
plot_bar(tax_glom(physeq_unite_rel, "Phylum"), fill="Phylum") + facet_grid(.~treatment *time, scale="free_x", space = "free_x")

```
**Initial phyloseq object with 962 ASVs in 48 samples is created. Total number of sequences is 185,825.**

## filter phyloseq object

```{r filter phyloseq object}

#remove non-AMF 
physeq_unite_Filtered <- subset_taxa(physeq_unite, !Phylum %in% c ("p__Basidiomycota", "p__Ascomycota")) #we remove non-AMF and now we have 955 ASVs
physeq_unite_Filtered

physeq_unite_Filtered_rel <- subset_taxa(physeq_unite_rel, !Phylum %in% c ("p__Basidiomycota", "p__Ascomycota"))

plot_bar(tax_glom(physeq_unite_Filtered_rel, "Phylum"), fill="Phylum")

sum(sample_sums(physeq_unite)) #185825
sum(sample_sums(physeq_unite_Filtered)) #185364
sort(sample_sums(physeq_unite_Filtered), decreasing = F) #we will discard samples with less than 500 reads 

```

## phyloseq object with only AMF (Glomeromycota)

```{r AMF phyloseq object}

physeq_AMF <- physeq_unite_Filtered

#compute prevalence of each feature, store as data.frame
prevdf=apply(X=otu_table(physeq_AMF), 
             MARGIN=ifelse(taxa_are_rows(physeq_AMF), yes=1, no=2),
             FUN=function(x){sum(x>0)})

#add taxonomy and total read frames to this data.frame
prevdf=data.frame(Prevalence=prevdf,
                  TotalAbundance=taxa_sums(physeq_AMF), tax_table(physeq_AMF))

min(sample_sums(physeq_AMF)) #404
max(sample_sums(physeq_AMF)) #11426
median(sample_sums(physeq_AMF)) #3414.5
mean(sample_sums(physeq_AMF)) #3861.75

#how many taxa are there? 
unique(ntaxa(physeq_AMF)) #955

#save phyloseq object
saveRDS(physeq_AMF, "/Users/Katja/Box Sync/PhD Lund Katja/Sequencing/PacBio AMF/Sequencing data AMF/dada2/AMF_DOK trial/PacBio_AMF_workflow/results_dada2/phyloseq_AMF.rds")

```
**955 ASVs in Glomeromycota phylum**

## rarefaction curves

```{r rarefaction curves}

rarecurve(otu_table(physeq_AMF), step=100, label = FALSE, xlab="Number of sequences",  ylab="Number of ASVs")

barplot(sort(sample_sums(physeq_AMF)),
        ylab= "Number of reads", xlab="Sample ID")

```
**To determine the completeness of our sampling efforts, we plotted rarefaction curves for the 48 samples. Sufficient sequencing depth to recover the majority of AMF ASVs reached.**

#Convert from phyloseq to vegan or from vegan to phyloseq

```{r vegan_phyloseq functions}

# convert the sample_data() within a phyloseq object to a vegan compatible data object
pssd2veg <- function(physeq) {
  sd <- sample_data(physeq)
  return(as(sd,"data.frame"))
}

# convert the otu_table() within a phyloseq object to a vegan compatible data object
psotu2veg <- function(physeq) {
  OTU <- otu_table(physeq)
  if (taxa_are_rows(OTU)) {
    OTU <- t(OTU)
  }
  return(as(OTU, "matrix"))
}

```

# COMMUNITY COMPOSITION 
+ here I will explore the community composition on genus level
+ agglomerate on genus level
+ PERMANOVA with BC 
+ plot PCoA/NMDS

# GENUS level 

```{r community composition genus level}

## agglomerate on genus level 

length(get_taxa_unique(physeq_AMF, taxonomic.rank = "Genus"))

# agglomerate taxa at the genus level (combine all with the same name) and remove all taxa without genus level assignment

physeq_AMF_genus = tax_glom(physeq_AMF, "Genus", NArm = T)
physeq_AMF_genus #agglomerated on the genus level

sum(sample_sums(physeq_AMF_genus)) #128352

unique(tax_table(physeq_AMF_genus)[,6]) #12

sort(sample_sums(physeq_AMF_genus), decreasing = F) #we will remove 3 samples

#keep samples with more than 500 reads 
physeq_AMF_genus_500 <- prune_samples(sample_sums(physeq_AMF_genus) >=500, physeq_AMF_genus)

sort(sample_sums(physeq_AMF_genus_500))
plot_bar((physeq_AMF_genus_500))
unique(ntaxa(physeq_AMF_genus_500)) #12
any(taxa_sums(physeq_AMF_genus_500) == 0)

#rank-abundance barplot
par(mar = c(5, 10, 4, 2) + 0.1) # make more room on bottom margin
N <- 12
barplot(sort(taxa_sums(physeq_AMF_genus_500), TRUE)[1:N]/nsamples(physeq_AMF_genus_500), las=2)

#rarefaction
unite_genus_rare <- rarefy_even_depth(physeq_AMF_genus_500, sample.size = min(sample_sums(physeq_AMF_genus_500)), 6020, replace=F, verbose = T) # rarefication on the lowest number of reads 

sort(sample_sums(unite_genus_rare))

```
**Agglomeration on genus level, after rarefaction on 531 reads we have 45 samples.**

##plot ordination on genus level

```{r plot ordination genus level}

#plot PCoA
genus_unite_pcoa <- phyloseq::ordinate(unite_genus_rare, method = "PCoA") # building pcoa

plot_ordination(unite_genus_rare, genus_unite_pcoa, color = "treatment", shape = "time") + geom_point(size = 3) + theme_bw()
plot_ordination(unite_genus_rare, genus_unite_pcoa, color = "farming_system", shape = "time") + geom_point(size = 3) + theme_bw()

plot_ordination(unite_genus_rare, genus_unite_pcoa, type="samples", color="farming_system",label="sample_ID")+
               geom_text(mapping = aes(label = sample_ID), size =2, vjust = 1.5) +
               geom_point(size=5) +
               ggtitle("Agglomerated on genus level") +
               facet_grid(~time)

#plot NMDS
set.seed(0902)
genus_unite_nmds <- phyloseq::ordinate(unite_genus_rare, method = "NMDS") 
genus_unite_nmds$stress #0.1902684

plot_ordination(unite_genus_rare, genus_unite_nmds, color = "treatment", shape = "time") + geom_point(size = 3) + theme_bw() 
plot_ordination(unite_genus_rare, genus_unite_nmds, color = "farming_system", shape = "time") + geom_point(size = 3) + theme_bw() 

```

# NMDS ordination (genus level)

```{r nmds ordination}

#transfer OTU table from phyloseq into a vegan object
vegan_AMF_genus<-psotu2veg(unite_genus_rare)

#transfer sample data from phyloseq into a vegan object
veganSample_AMF_genus<-pssd2veg(unite_genus_rare)

#rename columns from ASV to genus name 
colnames(vegan_AMF_genus) <- c("g__Paraglomus",  "g__Acaulospora", "g__Septoglomus", "g__Glomus", "g__Claroideoglomus", "g__Gigaspora", "g__Funneliformis", "g__Diversispora", "g__Archaeospora", "g__Ambispora", "g__Dominikia",  "g__Palaeospora")
vegan_AMF_genus

#calculate the distance matrix
set.seed(0902)
nmds_ord <- metaMDS(vegan_AMF_genus, distance = "bray", k=2, trymax=1000, autotransform=T, permutations = 999)
nmds_ord$stress
nmds_ord$species

plot_ordination(unite_genus_rare, nmds_ord, color = "farming_system", shape = "time") + geom_point(size = 3) + theme_bw()

#stress is goodness of fit 
goodness(nmds_ord)
stressplot(nmds_ord)
 
#this function draws NMDS ordination diagram with sites (=my samples)
plot(nmds_ord)
plot(nmds_ord, display = 'sites', type = 't')
plot(nmds_ord, display = 'species', type = 't')

#species spores 
envfit(nmds_ord, vegan_AMF_genus) 

plot(nmds_ord, type='n')
points(nmds_ord, display=c('sites'), choices=c(1, 2), pch=3, col='red')
text(nmds_ord, display=c('species'), choices=c(1, 2), col='blue', cex=0.7)

```

#envfit 

```{r calculate envfit}

#envfit with metadata 
nmds_meta <- as(sample_data(unite_genus_rel), "data.frame")
env_nmds <- nmds_meta[,5:24]

data.scores_nmds = as.data.frame(scores(nmds_ord, display = 'sites')) #save NMDS to dataframe
species.scores_nmds = as.data.frame(scores(nmds_ord, display = 'species'))

#add grouping variable to dataframe
data.scores_nmds <- cbind(as.data.frame(data.scores_nmds), farming_system = env_nmds$farming_system, 
                          treatment = env_nmds$treatment)
head(data.scores_nmds)

```

## calculate envfit for ndms ordination
## investigate the soil parameters which may be driving the distribution pattern

```{r envfit for nmds}

#calculate envfit
set.seed(0935)
env.fit <- envfit(scores(nmds_ord), env_nmds, permutations = 999, na.rm = TRUE, strata=nmds_meta$block)
env.fit

#extract scores from environment
env.scores <- as.data.frame(scores(env.fit, display = "vectors"))
env.scores <- cbind(env.scores, env.variables = rownames(env.scores), pval = env.fit$vectors$pvals)
head(env.scores)
sig.env <- subset(env.scores, pval<=0.05) #extract only significant soil parameters
head(sig.env)

#envfit write table for paper

envfit_nmds <- data.frame((env.fit$vectors)$r, (env.fit$vectors)$pvals)
write.table(envfit_nmds, "/Users/Katja/Box Sync/PhD Lund Katja/Sequencing/PacBio AMF/Sequencing data AMF/dada2/AMF_DOK trial/PacBio_AMF_workflow/results_dada2/envfit_nmds.txt", sep = "\t", quote = FALSE, row.names = T, col.names=T)

#vectors as continuous, factors as categorical
#vectors are soil parameters and factors (centroids) are treatment + farming system
en_coord_cont = as.data.frame(scores(env.fit, "vectors")) * ordiArrowMul(env.fit)
en_coord_cat = as.data.frame(scores(env.fit, "factors")) * ordiArrowMul(env.fit)

```

## final NMDS plot 

```{r NMDS plot on genus level}
#plot with significant environmental parameters

nmds_final <- ggplot() + geom_point(data = data.scores_nmds, aes(x = NMDS1, y = NMDS2, colour = farming_system), size = 5, alpha = 0.5) + theme_bw() + scale_colour_manual("Farming system", values=c("grey70", "grey25")) + theme(axis.title = element_text(size = 12, colour = "black"), axis.ticks = element_blank(), axis.text = element_blank(), legend.key = element_blank(), legend.title = element_text(size = 11, colour = "black"), legend.text = element_text(size = 10, colour = "black")) + labs(colour = "farming_system") + annotate("text", x=1.0, y=-0.7, size=5,label= paste("Stress =", round(nmds_ord$stress, digits=2))) + geom_segment(data = sig.env, aes(x = 0, xend=NMDS1, y=0, yend=NMDS2), arrow = arrow(length = unit(0.25, "cm")), colour = "black", lwd=0.3) + ggrepel::geom_text_repel(data = sig.env, aes(x=NMDS1, y=NMDS2, label = env.variables), cex = 4, color="black", direction = "both", segment.size = 0.25) + geom_point(data = en_coord_cat, aes(x = NMDS1, y = NMDS2), shape = "diamond", size = 5, alpha = 0.8, colour = "black") + geom_text(data = en_coord_cat, aes(x = NMDS1, y = NMDS2+0.04), label = row.names(en_coord_cat), colour = "black", fontface = "bold") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"))

print(nmds_final)
ggsave("results_dada2/nmds_final.pdf", width = 40, height = 20, units = "cm")
ggsave("results_dada2/nmds_final.tiff", width = 40, height = 20, units = "cm")

#ndms with dots representing genus 

ggplot() + geom_point(data = species.scores_nmds, aes(x = NMDS1, y = NMDS2), size = 5, alpha = 0.5) + theme_bw() + scale_colour_manual("Farming system", values=c("grey70", "grey25")) + theme(axis.title = element_text(size = 12, colour = "black"), axis.ticks = element_blank(), axis.text = element_blank(), legend.key = element_blank(), legend.title = element_text(size = 11, colour = "black"), legend.text = element_text(size = 10, colour = "black")) + labs(colour = "farming_system") + annotate("text", x=1.0, y=-0.7, size=5,label= paste("Stress =", round(nmds_ord$stress, digits=2))) + geom_segment(data = sig.env, aes(x = 0, xend=NMDS1, y=0, yend=NMDS2), arrow = arrow(length = unit(0.25, "cm")), colour = "black", lwd=0.3) + ggrepel::geom_text_repel(data = sig.env, aes(x=NMDS1, y=NMDS2, label = env.variables), cex = 4, color="black", direction = "both", segment.size = 0.25) + geom_point(data = en_coord_cat, aes(x = NMDS1, y = NMDS2), shape = "diamond", size = 5, alpha = 0.8, colour = "black") + geom_text(data = en_coord_cat, aes(x = NMDS1, y = NMDS2+0.04), label = row.names(en_coord_cat), colour = "black", fontface = "bold") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"))

```

###PERMANOVA with BC on genus level 

```{r permanova on genus level}

unite_genus_rel <- transform_sample_counts(unite_genus_rare, function(x) x/sum(x))
bray_unite_genus <- phyloseq::distance(unite_genus_rel, method = "bray")

meta.unite_genus <- as(sample_data(unite_genus_rare), "data.frame")

set.seed(1546)
perm.genus <- adonis2(bray_unite_genus ~ treatment+time+farming_system+
                    farming_system:treatment+
                    treatment:time+
                    time:farming_system,
                    strata=meta.unite_genus$block,
                    data = meta.unite_genus,permutations = 999)
perm.genus

#effect of time and farming system on genus composition with bray distance 
#we should highlight with constraint method

#save output for paper
permanova_genus <- as.data.frame(perm.genus)
permanova_genus <- permanova_genus[, c("Df","SumOfSqs", "R2", "F", "Pr(>F)")]
write.table(permanova_genus, "permanova_genus.txt", sep="\t",quote=F)

```
**Effect of the time and the farming system on genus composition with BC distance.We should highlight these effects with constrained method.**

```{r bray genus tss}

#tss normalization 
physeq_AMF_genus_500_TSS <- transform_sample_counts(physeq_AMF_genus_500, function(x) x/sum(x))

bray_tss <- phyloseq::distance(physeq_AMF_genus_500_TSS, method = "bray")
meta.tss <- as(sample_data(physeq_AMF_genus_500_TSS), "data.frame")

set.seed(1546)
perm.tss <- adonis2(bray_tss ~ treatment+time+farming_system+
                    farming_system:treatment+
                    treatment:time+
                    time:farming_system,
                    strata=meta.tss$block,
                    data = meta.tss,permutations = 999)
perm.tss

```

##weighted Unifrac distance on genus level

```{r weighted unifrac distance genus}

wuni_genus <- UniFrac(unite_genus_rare, weighted = TRUE, normalized = TRUE, parallel = FALSE, fast = TRUE)
meta.wuni_genus <- as(sample_data(unite_genus_rare), "data.frame")

set.seed(1420)
perm_mod_wuni_genus <- adonis2(wuni_genus ~ treatment+time+farming_system+
                                       farming_system:treatment+
                                       treatment:time+
                                       time:farming_system,
                                       strata=meta.wuni_genus$block,
                                       data = meta.wuni_genus,permutations = 999)
perm_mod_wuni_genus

```
**Time significance for weighted Unifrac on genus level AMF composition.**

##unweighted Unifrac distance on genus level

```{r unweighted unifrac distance genus}

uni_genus <- UniFrac(unite_genus_rare, weighted = FALSE, normalized = TRUE, parallel = FALSE, fast = TRUE)
meta.uni_genus <- as(sample_data(unite_genus_rare), "data.frame")

set.seed(1420)
perm_mod_uni_genus <- adonis2(uni_genus ~ treatment+time+farming_system+
                                     farming_system:treatment+
                                     treatment:time+
                                     time:farming_system,
                                     strata=meta.uni_genus$block,
                                     data = meta.uni_genus,permutations = 999)
perm_mod_uni_genus
```
**Slight interaction between treatment and time for genus AMF composition with unweighted UniFrac.**

# Constrained analysis with db-RDA, to highlight effects
###Plot only the variation in your data that explains changes in community composition

```{r plot dbrda}

set.seed(1120)

#add volumetric soil water content (VWC)

veganSample_AMF_genus$VWC<-veganSample_AMF_genus$WC*veganSample_AMF_genus$BD
summary(veganSample_AMF_genus$VWC)

#create the distance matrix
dbrda <- dbrda(vegan_AMF_genus ~ farming_system+time+Condition(block),veganSample_AMF_genus,dist="bray")
head(scores(dbrda, display = 'sites'))
smry <- summary(dbrda)

sppscores(dbrda) <- vegan_AMF_genus

anova(dbrda)  # overall test of the significant of the analysis
anova(dbrda, by="axis")
anova(dbrda, by="term", permutations = 999)

ordiplot(dbrda,type="t",scaling=2)
ordiplot(dbrda,type="t",scaling=1)

#check constrained and unconstrained variance
dbrda$CCA$tot.chi/dbrda$tot.chi

constrained_eig <- dbrda$CCA$eig/dbrda$tot.chi*100
unconstrained_eig <- dbrda$CA$eig/dbrda$tot.chi*100
expl_var <- c(constrained_eig, unconstrained_eig)
barplot (expl_var[1:20], col = c(rep ('red', length (constrained_eig)), rep ('black', length (unconstrained_eig))),
         las = 2, ylab = '% variation')

#calculate amount of variation explained by the axis
b_xlabel<-paste0("db-RDA1"," ","[", round(((dbrda$CCA$eig[1]/dbrda$CA$tot)*100),1), "%]" )
b_ylabel<-paste0("db-RDA2"," ","[", round(((dbrda$CCA$eig[2]/dbrda$CA$tot)*100),1), "%]" )

#the two variables explain 17.3% of the variance (Eigenvalues for constrained axes/divided by total variance (inertia))
#the first constrained axis (RDA1) explains 
0.8716/7.1219
#12.2% of the variance

#the second constrained axis (RDA2) explains 
0.3628/7.1219
#5.09% of the variance

#first unconstrained axis (MDS1) represents 45% of the total variance, which is more than the variance explained by both explanatory variables together
#the first two unconstrained explain 56.8% 
#This means that the dataset may be structured by some strong environmental variable(s)


#fortify: transfer into data frame that can be used for ggplot
scrs <- fortify(dbrda)

#select site (-> Samples)
sites <- subset(scrs, subset = Score == "sites") 

#select species (-> taxa)
species <- subset(scrs, subset = Score == "species")

(Time<-veganSample_AMF_genus$time) #choose group variable here
(System<-veganSample_AMF_genus$farming_system) #choose shape variable
df <- cbind(sites, Time , System) ## add on the group variable

```


```{r}

df1  <- data.frame(smry$species[,1:2]) #dbrda1, 2
df2  <- data.frame(smry$centroids[,1:2]) #loadings for dbrda1, 2


#this plot dots are plotted
rda.plot <- ggplot(df1, aes(x=dbRDA1, y=dbRDA2)) + 
  geom_text(aes(label=rownames(df1)),size=4) + 
  geom_hline(yintercept=0, linetype="dotted") +
  geom_vline(xintercept=0, linetype="dotted") +
  coord_fixed()
  
#with this command we add arrows
rda.biplot <- rda.plot + geom_segment(data=df2, aes(x=0, xend=dbRDA1, y=0, yend=dbRDA2), 
              color="red", arrow=arrow(length=unit(0.01,"npc"))) +
              geom_text(data=df2, 
              aes(x=dbRDA1,y=dbRDA2,label=rownames(df2),
              hjust=0.5*(1-sign(dbRDA1)),vjust=0.5*(1-sign(dbRDA2))), color="red", size=4)

rda.biplot

```


```{r}

#plot diamonds
rda.plot +  geom_point(data = en_coord_cat_dbrda, aes(x = dbRDA1, y = dbRDA2), shape = "diamond", size = 8, alpha = 0.8, colour = "blue") + geom_text(data = en_coord_cat_dbrda, aes(x = dbRDA1, y = dbRDA2), label = row.names(en_coord_cat_dbrda), colour = "blue", fontface = "bold") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"))

#plot environmental variables 
rda.plot + geom_segment(data = sig.env_dbrda,
               aes(x = 0, xend = dbRDA1,
                   y = 0, yend = dbRDA2),
               arrow = arrow(length = unit(2.5, "mm")),
               colour = "black",
               alpha=1,
               size=0.6,
               lineend ="round",
               linejoin="round") + 
               ggrepel::geom_text_repel(data = sig.env_dbrda, aes(x=dbRDA1, y=dbRDA2, label =env.variables), cex = 4,                color="blue", direction = "both", segment.size = 0.25)
```

## my version for the dbrda plot 

```{r dbrda katja}

dbrda_katja <- ggplot(df, aes(x = dbRDA1, y = dbRDA2)) + geom_point(aes(colour = System, shape = Time), size = 5,alpha=0.8) +
    scale_color_manual(values = c("#BEBADA", "#FB8072")) + labs(x = paste0("db-RDA1"," ","[", round(((dbrda$CCA$eig[1]/dbrda$CA$tot)*100),1), "%]" ), y = paste0("db-RDA2"," ","[", round(((dbrda$CCA$eig[2]/dbrda$CA$tot)*100),1), "%]" )) + 
    geom_vline(xintercept = 0, linetype="dotted") +
    geom_hline(yintercept = 0, linetype="dotted") +
    theme_bw() + 
    theme(text = element_text(size = 14)) + 
    ggtitle("Distance-based redundancy analysis (dbRDA) of AMF and environmental variables") + theme(axis.title = element_text(size = 12, colour = "black"), axis.ticks = element_blank(), axis.text = element_blank(), legend.key = element_blank(), legend.title = element_text(size = 11, colour = "black"), legend.text = element_text(size = 10, colour = "black")) + labs(colour = "Farming system", shape= "Time of sampling")

print(dbrda_katja)

## environmental variables 

names(veganSample_AMF_genus)
env_dbrda <- veganSample_AMF_genus[,2:25]
env_dbrda <- env_dbrda[,-c(2,3,4)]

data.scores_dbrda = as.data.frame(scores(dbrda, display = 'sites')) #save to dataframe

#extract species
species.scores_dbrda = as.data.frame(scores(dbrda, display = 'species'))

#add grouping variable to dataframe
data.scores_dbrda <- cbind(as.data.frame(data.scores_dbrda), farming_system = env_dbrda$farming_system, time = env_dbrda$time)
head(data.scores_dbrda)

set.seed(1722)
envfit_dbrda <- envfit(dbrda, env_dbrda, strata=veganSample_AMF_genus$block,na.rm = TRUE, display="lc")
envfit_dbrda

#extract scores from environment
env.scores_dbrda <- as.data.frame(scores(envfit_dbrda, display = "vectors"))
env.scores_dbrda <- cbind(env.scores_dbrda, env.variables = rownames(env.scores_dbrda), pval = envfit_dbrda$vectors$pvals)

head(env.scores_dbrda)
sig.env_dbrda <- subset(env.scores_dbrda, pval<=0.05) #extract only significant soil parameters
View(sig.env_dbrda)


#vectors as continuous, factors as categorical
#vectors are soil parameters and factors (centroids) are time + farming system
en_coord_cont_dbrda = as.data.frame(scores(envfit_dbrda, "vectors")) * ordiArrowMul(envfit_dbrda)
en_coord_cat_dbrda = as.data.frame(scores(envfit_dbrda, "factors")) * ordiArrowMul(envfit_dbrda)

#envfit for species
spp.fit <- envfit(dbrda, env_dbrda, strata=veganSample_AMF_genus$block,na.rm = TRUE, display="lc")


#plot with environmental parameters 

dbrda_katja_env <- dbrda_katja + geom_segment(data = sig.env_dbrda,
               aes(x = 0, xend = dbRDA1,
                   y = 0, yend = dbRDA2),
               arrow = arrow(length = unit(2.5, "mm")),
               colour = "black",
               alpha=1,
               size=0.6,
               lineend ="round",
               linejoin="round") + 
               ggrepel::geom_text_repel(data = sig.env_dbrda, aes(x=dbRDA1, y=dbRDA2, label =env.variables), cex = 4,                color="black", direction = "both", segment.size = 0.25) + geom_point(data = en_coord_cat_dbrda, aes(x                = dbRDA1, y = dbRDA2), shape = "diamond", size = 8, alpha = 0.8, colour = "black") + geom_text(data =                en_coord_cat_dbrda, aes(x = dbRDA1, y = dbRDA2), label = row.names(en_coord_cat_dbrda), colour =                     "black", fontface = "bold") + theme(panel.grid.major = element_blank(), panel.grid.minor =                           element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black"))

print(dbrda_katja_env)


```
**This plot needs to be adjusted a little bit more.**

# ALPHA diversity indices

```{r alpha_div}

#the alpha diversity metrics were calculated based on samples rarefied to the lowest number of reads, calcualted per sample
#alpha diversity estimates on rarefied data
#we calculate Observed and Shannon for each sample

alpha_div <- data.frame(estimate_richness(unite_ASV_rare, split=TRUE, measures = c("Observed", "Shannon")), sample_data(unite_ASV_rare))
View(alpha_div)

plot_richness(unite_ASV_rare, x="treatment", color="farming_system", measures=c("Observed","Shannon")) + stat_boxplot(geom = "errorbar") + geom_boxplot() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) + scale_color_manual(values=wes_palette(n=2, name="Cavalcanti1")) + xlab("Treatment") + ggtitle("AMF alpha diversity") + ylab("Alpha metrics")

write.csv(alpha_div, "/Users/Katja/Box Sync/PhD Lund Katja/Sequencing/PacBio AMF/Sequencing data AMF/dada2/AMF_DOK trial/PacBio_AMF_workflow/results_dada2/alpha_div.csv")

```
**Observed ASV richness and Shannon diversity index are calculated.**

## prepare data for BRMS model

```{r prepare data for BRMS model}

#import data
head(alpha_div)

data_brms <- alpha_div
head(data_brms)
str(data_brms)

```

## BRMS model for observed richness 

```{r BRMS for observed richness}

observed_brms <-brm(formula = (Observed)~0+treatment*farming_system+(1|block/plot)+(1|time),
            data = data_brms,
            family="gaussian",
            seed = 1041,
            warmup = 2000,#The number of warmup iterations should 
            #not be larger than iter and the default is iter/2.
            iter = 6000, 
            chains = 5,
            control = list(adapt_delta = 0.999, max_treedepth = 15))

# Save an object to a file
saveRDS(observed_brms, "/Users/Katja/Box Sync/PhD Lund Katja/Sequencing/PacBio AMF/Sequencing data AMF/dada2/AMF_DOK trial/PacBio_AMF_workflow/results_dada2/observed_brms.rds")

#reload it so you don't have to run it again
observed_brms <- readRDS("/Users/Katja/Box Sync/PhD Lund Katja/Sequencing/PacBio AMF/Sequencing data AMF/dada2/AMF_DOK trial/PacBio_AMF_workflow/results_dada2/observed_brms.rds")

#check model fit 
yfit_observed <- data_brms$Observed
yrep_observed <- posterior_predict(observed_brms, draws = length(yfit_observed))

launch_shinystan(observed_brms)

#explore results
summary(observed_brms)
bayes_R2(observed_brms)

#marginal effects
marginal_effects(observed_brms)

```
**BRMS model for Observed richness is created.**

## plot BRMS observed richness

```{r plot brms for observed richness}

#we can plot the summary of the posterior distribution.
#make a data frame that contains the parameters of interest
#here: all of them

data_brms$farming_system <- as.factor(data_brms$farming_system)
data_brms$treatment <- as.factor(data_brms$treatment)

newdat <- expand.grid(
  farming_system = factor(c("BIODYN", "CONMIN"), levels=levels(data_brms$farming_system)),
  treatment = factor(c("C","R", "RC"),levels=levels(data_brms$treatment)))
head(newdat)

#use the function "fitted" from brms to get fitted means of the posterior for treatments
#It summarizes from the posterior and calculates meadian with 95% credible interval
#= we are 95% sure that the real estimate is within this interval

fit_observed = fitted(observed_brms, newdata = newdat, robust=T, re_formula = NA,summary = TRUE, probs = c(0.025, 0.975))  
fit_observed

# no colnames, I add them manually
fitdf_observed_plot = cbind(newdat, fit_observed)
fitdf_observed_plot

#prepare and extract results table
fitdf_observed<-fitdf_observed_plot[, c("farming_system","treatment","Estimate","Q2.5","Q97.5")]
write.table(fitdf_observed,"/Users/Katja/Box Sync/PhD Lund Katja/Sequencing/PacBio AMF/Sequencing data AMF/dada2/AMF_DOK trial/PacBio_AMF_workflow/results_dada2/observed_alphadiv_brms.txt",sep="\t",quote=F)

#change order of treatment in fitted values
fitdf_observed_plot$treatment<-factor(fitdf_observed_plot$treatment, levels=c("R", "RC", "C"))

#this is the dataframe i will use for plotting
pos.dodge <- position_dodge(0.7) # move them .7 to the left and right

#make the final plot, without raw data
fitted_observed<-ggplot(data = fitdf_observed_plot, 
                     aes(x = farming_system,
                         y =Estimate,
                         color = treatment,
                         shape=treatment)) +
  geom_point(size=6,position=pos.dodge) +
  geom_errorbar(aes(ymin=Q2.5,
                    ymax=Q97.5),
                width=0,
                position=pos.dodge,
                size=1.2, show.legend = F) +
  scale_color_manual(values =  c("palegreen4",
                                 "steelblue2",
                                 "tomato2"), name  ="") +
  scale_shape_manual(values = c(15, 17, 19),name  ="")+
  xlab("Farming system")+
  ylab("Observed ASV")+theme_bw()

print(fitted_observed)
ggsave("results_dada2/observed_brms.tiff", width = 18, height = 10, units = "cm")

#get location of the means including credible intervals from here:
fitdf_observed_plot<-as.data.frame(fitdf_observed_plot)

#if you want, you can also calculate differences between treatments based on the posterior
##calucate differences with CrI, you need the whole posterior
#the whole posterior distribution for me. I save it as dataframe (fit1)

fit_observed = as.data.frame(fitted(observed_brms, newdata=newdat,
                           re_formula = NA, summary = FALSE))

#this is the whole posterior, not summarized as before

#add names
colnames<-as.character(interaction(newdat$farming_system, newdat$treatment))

colnames(fit_observed)<-colnames
names(fit_observed)

#calculate the mean differences between systems across the roofs
BIODYN_brms_obs<-(fit_observed$BIODYN.C+fit_observed$BIODYN.RC+fit_observed$BIODYN.R)/3
mean(BIODYN_brms_obs)
sd(BIODYN_brms_obs)
CONMIN_brms_obs<-(fit_observed$CONMIN.C+fit_observed$CONMIN.RC+fit_observed$CONMIN.R)/3
mean(CONMIN_brms_obs)
sd(CONMIN_brms_obs)

diff_brms_obs<-(BIODYN_brms_obs-CONMIN_brms_obs)

#use the quantile function to get mean of that differences with CrI
round(quantile(diff_brms_obs, probs=c(0.025, 0.5, 0.975)),2)
#this is a result
mean(diff_brms_obs)

```

## BRMS model for Shannon index 

```{r BRMS for observed ASVs richness}

shannon_brms <-brm(formula = (Shannon)~0+treatment*farming_system+(1|block/plot/treatment) + (1|time),
            data = data_brms,
            family="gaussian",
            seed = 1041,
            warmup = 2000,#The number of warmup iterations should 
            #not be larger than iter and the default is iter/2.
            iter = 6000, 
            chains = 5,
            control = list(adapt_delta = 0.999, max_treedepth = 15))

# Save an object to a file
saveRDS(shannon_brms, "/Users/Katja/Box Sync/PhD Lund Katja/Sequencing/PacBio AMF/Sequencing data AMF/dada2/AMF_DOK trial/PacBio_AMF_workflow/results_dada2/shannon_brms.rds")

#reload it so you don't have to run it again
shannon_brms <- readRDS("/Users/Katja/Box Sync/PhD Lund Katja/Sequencing/PacBio AMF/Sequencing data AMF/dada2/AMF_DOK trial/PacBio_AMF_workflow/results_dada2/shannon_brms.rds")

#check model fit 
yfit_shannon <- data_brms$Shannon
yrep_shannon <- posterior_predict(shannon_brms, draws = length(yfit_shannon))

launch_shinystan(shannon_brms)

#explore results
summary(shannon_brms)

#marginal effects
marginal_effects(shannon_brms)

```
**BRMS model for Shannon index is created.**

## plot brms for Shannon index

```{r plot brms for Shannon}

#use the function "fitted" from brms
#to get fitted means of the posterior for treatments
#It summarizes from the posterior and calculates meadian with 95% credible interval
#= we are 95% sure that the real estimate is within this interval

fit_shannon = fitted(shannon_brms, newdata = newdat, robust=T, re_formula = NA,summary = TRUE,probs = c(0.025, 0.975))
fit_shannon

# no colnames, I add them manually
fitdf_shannon_plot = cbind(newdat, fit_shannon)
fitdf_shannon_plot

#prepare and extract results table
fitdf_shannon<-fitdf_shannon_plot[, c("farming_system","treatment","Estimate","Q2.5","Q97.5")]
write.table(fitdf_shannon,"/Users/Katja/Box Sync/PhD Lund Katja/Sequencing/PacBio AMF/Sequencing data AMF/dada2/AMF_DOK trial/PacBio_AMF_workflow/results_dada2/shannon_alphadiv_brms.txt",sep="\t",quote=F)

#change order of treatment in fitted values
fitdf_shannon_plot$treatment<-factor(fitdf_shannon_plot$treatment, levels=c("R", "RC", "C"))

#this is the dataframe i will use for plotting
pos.dodge <- position_dodge(0.7) # move them .7 to the left and right

#make the final plot
fitted_shannon<-ggplot(data = fitdf_shannon_plot, 
                     aes(x = farming_system,
                         y =Estimate,
                         color = treatment,
                         shape=treatment)) +
  geom_point(size=6,position=pos.dodge) +
  geom_errorbar(aes(ymin=Q2.5,
                    ymax=Q97.5),
                width=0,
                position=pos.dodge,
                size=1.2, show.legend = F) +
  scale_color_manual(values =  c("palegreen4",
                                 "steelblue2",
                                 "tomato2"), name  ="") +
  scale_shape_manual(values = c(15, 17, 19),name  ="")+
  xlab("Farming system")+
  ylab("Shannon diversity index")+theme_bw()

print(fitted_shannon)
ggsave("results_dada2/shannon_brms.tiff", width = 18, height = 10, units = "cm")

#get location of the means including credible intervals from here:
fitdf_shannon_plot<-as.data.frame(fitdf_shannon_plot)

#if you want, you can also calculate differences between treatments based on the posterior
##calucate differences with CrI, you need the whole posterior
#the whole posterior distribution for me. I save it as dataframe (fit1)

fit_shannon = as.data.frame(fitted(shannon_brms, newdata=newdat,
                           re_formula = NA, summary = FALSE))

#this is the whole posterior, not summarized as before

#add names
colnames<-as.character(interaction(newdat$farming_system, newdat$treatment))

colnames(fit_shannon)<-colnames
names(fit_shannon)

#calculate the mean differences between systems across the roofs
BIODYN_brms_shannon<-(fit_shannon$BIODYN.C+fit_shannon$BIODYN.RC+fit_shannon$BIODYN.R)/3
mean(BIODYN_brms_shannon)
sd(BIODYN_brms_shannon)
CONMIN_brms_shannon<-(fit_shannon$CONMIN.C+fit_shannon$CONMIN.RC+fit_shannon$CONMIN.R)/3
mean(CONMIN_brms_shannon)
sd(CONMIN_brms_shannon)

diff_brms_shannon <- (BIODYN_brms_shannon-CONMIN_brms_shannon)

#use the quantile function to get mean of that differences with CrI
round(quantile(diff_brms_shannon, probs=c(0.025, 0.5, 0.975)),2)
#this is a result
mean(diff_brms_shannon)

```

## phylogenetic diversity, calculated with Faith's PD index
Faith's PD is defined as the total branch length spanned by the tree including all species in a local community, optionally including the root node of the phylogeny.

```{r faith index}
#The pd function returns two values for each community, Faith's PD and observed species richness (SR).

library(picante); packageVersion("picante") #1.8

faith_asvtable <- as.data.frame(unite_ASV_rare@otu_table)
faith_tree <- unite_ASV_rare@phy_tree

#check if the tree is rooted or not
faith_tree

#if yes
faith_pd <- pd(faith_asvtable, faith_tree)
head(faith_pd)

write.csv(faith_pd, "/Users/Katja/Box Sync/PhD Lund Katja/Sequencing/PacBio AMF/Sequencing data AMF/dada2/AMF_DOK trial/PacBio_AMF_workflow/results_dada2/faith_index.csv")

#add phylogenetic_diversity to alpha diversity file and to brms data
alpha_div$phylogenetic_diversity <- faith_pd$PD
data_brms$Faith <- faith_pd$PD

#Plot Faith's PD by farming system
boxplot(faith_pd$PD ~ unite_ASV_rare@sam_data$farming_system, xlab="Farming system", ylab="Faith's PD")
t.test(faith_pd$PD ~  unite_ASV_rare@sam_data$farming_system)

#Plot Faith's PD by treatment
boxplot(faith_pd$PD ~ unite_ASV_rare@sam_data$treatment, xlab="Treatment", ylab="Faith's PD") 

#Compare PD and species richness
plot(faith_pd$PD ~ faith_pd$SR, xlab = "Species richness", ylab = "Faith's PD")

#Plot PD index 
faith_plot <- ggplot(alpha_div, aes(x=treatment, y=phylogenetic_diversity, fill=farming_system)) + stat_boxplot(geom = "errorbar") + xlab("Treatment") + ylab("Faith's PD") +  scale_x_discrete(limits=c("C","R","RC")) + geom_boxplot() + scale_fill_manual(values=c("darkgreen", "darkgoldenrod1")) + theme(axis.text.x = element_text(size = 7.5)) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank(), axis.line = element_line(colour = "black")) 

print(faith_plot)

```

# INDICATOR SPECIES ANALYSIS
####to investigate if there are indicators of the farming system, the time of sampling and drought treatment

```{r indicator species analysis}

#Transfer Phyloseq into a vegan ASV table
ind_analysis <- psotu2veg(physeq_AMF)

#meta file for indicators 
ind_meta <- as(sample_data(physeq_AMF), "data.frame")

ind_time <- ind_meta$time
ind_treatment <- ind_meta$treatment
ind_system <- ind_meta$farming_system

length(unique(ind_treatment))
length(unique(ind_time))
length(unique(ind_system))

#A = 1.0000: Species is a good indicator for the Group, because it occurs ONLY in sites, belonging to this group
#B: proportion of sites belonging to the group that contain the species.

#indicators for farming system 

set.seed(1809)
indval_System = multipatt(ind_analysis,ind_system,func = "IndVal", control = how(nperm=999))
summary(indval_System,indvalcomp=TRUE)
summary(indval_System, alpha=1,indvalcomp=TRUE)

#indicators for drought treatment

set.seed(1809)
indval_Treatment = multipatt(ind_analysis,ind_treatment,func = "IndVal", control = how(nperm=999))
summary(indval_Treatment,indvalcomp=TRUE)
summary(indval_Treatment, alpha=1,indvalcomp=TRUE)

#indicators for the time of sampling

set.seed(1809)
indval_Time = multipatt(ind_analysis,ind_time,func = "IndVal", control = how(nperm=999))
summary(indval_Time,indvalcomp=TRUE)
summary(indval_Time, alpha=1,indvalcomp=TRUE)

```
**4 indicators for farming system, only for CONMIN, 3 indicators for the drought treatment (R=1, C=2), 2 indicators for time, only T1.**


## indicators for the farming systems

```{r indicators system}

indicators_system <- indval_System$sign

ind_BIODYN <- as.matrix(indicators_system[which(indicators_system$s.BIODYN == 1 & indicators_system$p.value < 0.05),])
ind_CONMIN <- as.matrix(indicators_system[which(indicators_system$s.CONMIN == 1 & indicators_system$p.value < 0.05),])

CONMIN_BIODYN <- rbind(ind_BIODYN, ind_CONMIN)
colnames(CONMIN_BIODYN)[1:2] <-c("BIODYN","CONMIN")

## Total number of indicator ASVs
length(unique(rownames(CONMIN_BIODYN)))

```
**4 indicators for CONMIN.**

## indicators for the drought treatment

```{r indicators treatment}

indicators_treatment <- indval_Treatment$sign

ind_R <- as.matrix(indicators_treatment[which(indicators_treatment$s.R == 1 & indicators_treatment$p.value < 0.05),])
ind_C <- as.matrix(indicators_treatment[which(indicators_treatment$s.C == 1 & indicators_treatment$p.value < 0.05),])
ind_RC <- as.matrix(indicators_treatment[which(indicators_treatment$s.RC == 1 & indicators_treatment$p.value < 0.05),])

R_C_RC <- rbind(ind_R, ind_C, ind_RC)
colnames(R_C_RC)[1:3] <-c("C","R","RC")

## Total number of indicator OTUS
length(unique(rownames(R_C_RC)))

```
**3 indicators for the drought treatment, 2 for C and 1 for R.**

## indicators for the time of sampling

```{r indicators time}

indicators_time <- indval_Time$sign

ind_T1 <- as.matrix(indicators_time[which(indicators_time$s.T1 == 1 & indicators_time$p.value < 0.05),])
ind_T3 <- as.matrix(indicators_time[which(indicators_time$s.T3 == 1 & indicators_time$p.value < 0.05),])

T1_T3 <- rbind(ind_T1, ind_T3)
colnames(T1_T3)[1:2] <-c("T1", "T3")

## Total number of indicator OTUS
length(unique(rownames(T1_T3)))

```
**2 indicators for T1.**

# TAXONOMIC COMPOSITION on different taxonomic levels

```{r}

View(unite_ASV_rel@otu_table)

```

## Class level
+ 3 classes 
+ Glomeromycetes as the most abundant 

```{r investigate class level}

#taxonomy_AMF

unique(tax_table(unite_ASV_rel)[,3])

subset_class <- subset_taxa(unite_ASV_rel, Class %in% c("c__Paraglomeromycetes", "c__Glomeromycetes", "c__Archaeosporomycetes")) 

subset_class
subset_class = prune_samples(sample_sums(subset_class)>0, subset_class)

data_class <- subset_class %>%
              tax_glom(taxrank = "Class") %>%     #agglomerate at class level
              psmelt() %>%                        #melt to long format
              arrange(Class)                      #sort data frame alphabetically by class


# To change plot order of facet wrap,
# change the order of varible levels with factor()
data_class$treatment <- factor(data_class$treatment, levels = c("R", "RC", "C"))


#plot AMF class 
ggplot(data_class) + geom_col(mapping = aes(x = treatment:farming_system, y = Abundance, fill = Class), position = "fill", show.legend = TRUE) + scale_fill_brewer(palette="Dark2") + theme(axis.text.x = element_text(angle = 35, hjust = 1)) + scale_x_discrete(name ="Treatment:Farming system") + scale_fill_discrete(labels=c("Paraglomeromycetes", "Glomeromycetes", "Archaeosporomycetes")) + facet_wrap(~time)

```

## All orders 
+ there are 5 orders

```{r all orders AMF}

unique(tax_table(unite_ASV_rel)[,4])

subset_orders_AMF <- subset_taxa(unite_ASV_rel, Order %in% c("o__Diversisporales","o__Glomerales","o__Gigasporales", "o__Paraglomerales", "o__Archaeosporales"))

orders_AMF = prune_samples(sample_sums(subset_orders_AMF)>0, subset_orders_AMF)

orders_AMF <- orders_AMF %>%
              tax_glom(taxrank = "Order") %>%      #agglomerate at order level
              psmelt() %>%                         #melt to long format
              arrange(Order)

# To change plot order of facet wrap,
# change the order of varible levels with factor()
orders_AMF$treatment <- factor(orders_AMF$treatment, levels = c("R", "RC", "C"))

ggplot(orders_AMF) + geom_col(mapping = aes(x = treatment:farming_system, y = Abundance, fill = Order), position = "fill", show.legend = TRUE) + scale_fill_brewer(palette="Dark2") + theme(axis.text.x = element_text(angle = 35, hjust = 1)) + scale_x_discrete(name ="Treatment:Farming system") + scale_fill_discrete(labels=c("Archaeosporales", "Diversisporales", "Glomerales", "Paraglomerales")) + facet_wrap(~time)

```

## Focus on Glomeromycetes class
+ focus on Glomeromyctes class, as it is the most abundant one and three orders within it

```{r Glomeromycetes class}

unique(tax_table(unite_ASV_rel)[,4])

subset_orders <- subset_taxa(unite_ASV_rel, Order %in% c("o__Diversisporales","o__Glomerales","o__Gigasporales"))

glomeromycetes_orders = prune_samples(sample_sums(subset_orders)>0, subset_orders)

glomeromycetes_orders <- glomeromycetes_orders %>%
                         tax_glom(taxrank = "Order") %>%      #agglomerate at order level
                         psmelt() %>%                         #melt to long format
                         arrange(Order)                       #sort data frame alphabetically by order

# To change plot order of facet wrap,
# change the order of varible levels with factor()
glomeromycetes_orders$treatment <- factor(glomeromycetes_orders$treatment, levels = c("R", "RC", "C"))

ggplot(glomeromycetes_orders) + geom_col(mapping = aes(x = treatment:farming_system, y = Abundance, fill = Order), position = "fill", show.legend = TRUE) + scale_fill_brewer(palette="Dark2") + theme(axis.text.x = element_text(angle = 35, hjust = 1)) + scale_x_discrete(name ="Treatment:Farming system") + scale_fill_discrete(labels=c("Diversisporales", "Glomerales")) + facet_wrap(~time)

```

## Family level 
+ there are 8 families 

```{r family level}

unique(tax_table(unite_ASV_rel)[,5])

subset_family <- subset_taxa(unite_ASV_rel, Family %in% c("f__Archaeosporaceae", "f__Glomeraceae", "f__Diversisporaceae", "f__Ambisporaceae", "f__Acaulosporaceae", "f__Paraglomeraceae", "f__Gigasporaceae", "f__Claroideoglomeraceae")) 

subset_family
subset_family = prune_samples(sample_sums(subset_family)>0, subset_family)

data_family <- subset_family %>%
               tax_glom(taxrank = "Family") %>%
               psmelt() %>%
               arrange(Family)

# To change plot order of facet wrap,
# change the order of varible levels with factor()
data_family$treatment <- factor(data_family$treatment, levels = c("R", "RC", "C"))

ggplot(data_family) + geom_col(mapping = aes(x = treatment:farming_system, y = Abundance, fill = Family), position = "fill", show.legend = TRUE) + scale_fill_brewer(palette="Dark2") + theme(axis.text.x = element_text(angle = 35, hjust = 1)) + scale_x_discrete(name ="Treatment:Farming system") + scale_fill_discrete(labels=c("Acaulosporaceae", "Ambisporaceae", "Archaeosporaceae", "Claroideoglomeraceae", "Diversisporaceae", "Glomeraceae", "Paraglomeraceae")) + facet_wrap(~time)

```

## Genus level 
+ 12 genera
+ here we include NA

```{r genus level}

#here we will include unassigned

unique(tax_table(unite_ASV_rel)[,6])

subset_genera <- subset_taxa(unite_ASV_rel, Genus %in% c("g__Acaulospora", "g__Glomus", "g__Palaeospora", "NA", "g__Diversispora", "g__Funneliformis", "g__Paraglomus", "g__Ambispora", "g__Claroideoglomus", "g__Gigaspora", "g__Dominikia", "g__Archaeospora", "g__Septoglomus"))

subset_genera = prune_samples(sample_sums(subset_genera)>0, subset_genera)

data_genera <- subset_genera %>%
               tax_glom(taxrank = "Genus") %>%
               psmelt() %>%
               filter(Abundance > 0.01) %>%
               arrange (Genus)

#include NA
data_genera_NA <- subset_genera %>%
                  psmelt() %>%
                  arrange (Genus)

# To change plot order of facet wrap,
# change the order of varible levels with factor()
data_genera$treatment <- factor(data_genera$treatment, levels = c("R", "RC", "C"))

ggplot(data_genera) + geom_col(mapping = aes(x = treatment:farming_system, y = Abundance, fill = Genus), position = "fill", show.legend = TRUE) + scale_fill_brewer(palette="Dark2") + theme(axis.text.x = element_text(angle = 35, hjust = 1)) + scale_x_discrete(name ="Treatment:Farming system") + scale_fill_discrete(labels=c("Acaulospora", "Ambispora", "Archaeospora", "Claroideoglomus", "Diversispora", "Funneliformis", "Palaeospora", "Paraglomus", "Septoglomus", "Gigaspora", "Dominikia", "Glomus")) + facet_wrap(~time)

#with NA as others
ggplot(data_genera_NA) + geom_col(mapping = aes(x = treatment:farming_system, y = Abundance, fill = Genus), position = "fill", show.legend = TRUE) + scale_fill_brewer(palette="Dark2") + theme(axis.text.x = element_text(angle = 35, hjust = 1)) + scale_x_discrete(name ="Treatment:Farming system") + scale_fill_discrete(labels=c("Acaulospora", "Ambispora", "Archaeospora", "Claroideoglomus", "Diversispora", "Funneliformis", "Palaeospora", "Paraglomus", "Septoglomus", "Gigaspora", "Dominikia", "Glomus", "Other")) + facet_wrap(~time)

ggplot(data_genera) + geom_col(mapping = aes(x = treatment, y = Abundance, fill = Genus), position = "fill", show.legend = TRUE) + scale_fill_brewer(palette="Dark2") + theme(axis.text.x = element_text(angle = 35, hjust = 1)) + scale_x_discrete(name ="Treatment") + scale_fill_discrete(labels=c("Acaulospora", "Ambispora", "Archaeospora", "Claroideoglomus", "Diversispora", "Funneliformis", "Palaeospora", "Paraglomus", "Septoglomus", "Gigaspora", "Dominikia", "Glomus")) + facet_wrap(~time)          

```

# Summary 
+ UNITE database was used for taxonomic assignments
+ samples with less than 500 were removed
+ rarefaction on the lowest number of reads
+ AMF diversity: neither farming system nor drought treatment did have an effect on the two diversity metrics, observed number of ASVs and Shannon’s index of AMF
+ AMF community composition: data agglomerated on genus level, farming effect over time 
+ farming and time effect need to be highlighted with constrained method 
+ except root.DW and PO4_P all soil parameters had significant relations on the AMF community composition
+ there are indicators for system (CONMIN), time of the sampling and treatment 

# Session Info

```{r sessionInfo, include=TRUE, echo=TRUE}
sessionInfo()
```

